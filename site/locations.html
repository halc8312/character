<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ä¸€è¦§ | Character Database</title>
  <link rel="stylesheet" href="assets/app.css">
</head>
<body>
  <header class="header">
    <h1>ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹</h1>
    <nav>
      <a href="index.html">ä¸€è¦§</a>
      <a href="graph.html">ç›¸é–¢å›³</a>
      <a href="locations.html" class="active">ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³</a>
    </nav>
  </header>
  
  <main class="container">
    <h2 style="margin-bottom: 1rem;">ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³</h2>
    
    <div class="search-bar">
      <input 
        type="text" 
        id="searchInput" 
        class="search-input" 
        placeholder="å ´æ‰€åã€IDã§æ¤œç´¢..."
        autocomplete="off"
      >
    </div>
    
    <div class="filter-section" id="filterSection">
      <h3>ã‚¿ã‚¤ãƒ—ã§çµã‚Šè¾¼ã¿</h3>
      <div id="typeFilters" class="filter-group">
        <!-- Type filters will be inserted here -->
      </div>
    </div>
    
    <div class="status-bar">
      <span id="resultCount">èª­ã¿è¾¼ã¿ä¸­...</span>
      <span id="mapLinks" style="margin-left: auto;"></span>
    </div>
    
    <div id="locationTree" class="location-tree">
      <div class="loading">ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™...</div>
    </div>
  </main>
  
  <script src="assets/app.js"></script>
  <script>
    let allLocations = [];
    let allMaps = [];
    let activeTags = new Set();
    
    /**
     * Build hierarchical tree structure
     */
    function buildTree(locations) {
      const byParent = {};
      const roots = [];
      
      locations.forEach(loc => {
        const parentId = loc.parent_id || null;
        if (!byParent[parentId]) {
          byParent[parentId] = [];
        }
        byParent[parentId].push(loc);
      });
      
      function buildNode(loc) {
        const children = byParent[loc.id] || [];
        return {
          ...loc,
          children: children.map(buildNode)
        };
      }
      
      // Roots are locations with no parent or parent not in list
      const locationIds = new Set(locations.map(l => l.id));
      locations.forEach(loc => {
        if (!loc.parent_id || !locationIds.has(loc.parent_id)) {
          roots.push(buildNode(loc));
        }
      });
      
      return roots;
    }
    
    /**
     * Render location tree
     */
    function renderTree(tree, level = 0) {
      if (!tree || tree.length === 0) return '';
      
      return tree.map(node => {
        const hasChildren = node.children && node.children.length > 0;
        const indent = level * 20;
        
        return `
          <div class="location-node" style="margin-left: ${indent}px;">
            <a href="location.html?id=${App.escapeHtml(node.id)}" class="location-link">
              <span class="location-icon">${getTypeIcon(node.type)}</span>
              <span class="location-name">${App.escapeHtml(node.name)}</span>
              <span class="location-type tag">${App.escapeHtml(node.type || '')}</span>
            </a>
            ${node.description ? `<div class="location-desc">${App.escapeHtml(node.description.substring(0, 80))}${node.description.length > 80 ? '...' : ''}</div>` : ''}
            ${hasChildren ? renderTree(node.children, level + 1) : ''}
          </div>
        `;
      }).join('');
    }
    
    /**
     * Get icon for location type
     */
    function getTypeIcon(type) {
      const icons = {
        world: 'ğŸŒ',
        continent: 'ğŸ—ºï¸',
        country: 'ğŸ³ï¸',
        region: 'ğŸ“',
        city: 'ğŸ™ï¸',
        district: 'ğŸ˜ï¸',
        neighborhood: 'ğŸ ',
        street: 'ğŸ›¤ï¸',
        building: 'ğŸ¢',
        house: 'ğŸ¡',
        shop: 'ğŸª',
        school: 'ğŸ«',
        temple: 'â›©ï¸',
        guild: 'ğŸ›ï¸',
        office: 'ğŸ¢',
        hospital: 'ğŸ¥',
        station: 'ğŸš‰',
        room: 'ğŸšª',
        floor: 'ğŸ“¶',
        landmark: 'ğŸ—¿',
        park: 'ğŸŒ³',
        plaza: 'â›²',
        forest: 'ğŸŒ²',
        mountain: 'â›°ï¸',
        river: 'ğŸï¸',
        lake: 'ğŸ’§'
      };
      return icons[type] || 'ğŸ“Œ';
    }
    
    /**
     * Render locations
     */
    function renderLocations(locations) {
      const container = document.getElementById('locationTree');
      const countEl = document.getElementById('resultCount');
      
      if (locations.length === 0) {
        container.innerHTML = `
          <div class="no-results">
            <h3>ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“</h3>
            <p>æ¤œç´¢æ¡ä»¶ã‚’å¤‰æ›´ã™ã‚‹ã‹ã€locations/ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚</p>
          </div>
        `;
        countEl.textContent = '0ä»¶';
        return;
      }
      
      countEl.textContent = `${locations.length}ä»¶`;
      
      const tree = buildTree(locations);
      container.innerHTML = renderTree(tree);
    }
    
    /**
     * Render type filters
     */
    function renderFilters() {
      const typeFilters = document.getElementById('typeFilters');
      const types = new Set();
      
      allLocations.forEach(loc => {
        if (loc.type) types.add(loc.type);
      });
      
      const sortedTypes = Array.from(types).sort();
      
      typeFilters.innerHTML = sortedTypes.map(type => `
        <label class="filter-tag" data-type="${App.escapeHtml(type)}">
          <input type="checkbox" value="${App.escapeHtml(type)}">
          ${getTypeIcon(type)} ${App.escapeHtml(type)}
        </label>
      `).join('');
      
      // Hide filter section if no filters
      const filterSection = document.getElementById('filterSection');
      if (sortedTypes.length === 0) {
        filterSection.style.display = 'none';
      }
    }
    
    /**
     * Render map links
     */
    function renderMapLinks() {
      const container = document.getElementById('mapLinks');
      if (allMaps.length === 0) {
        container.innerHTML = '';
        return;
      }
      
      container.innerHTML = 'åœ°å›³: ' + allMaps.map(m => 
        `<a href="map.html?map=${App.escapeHtml(m.id)}" class="map-link">${App.escapeHtml(m.name)}</a>`
      ).join(' | ');
    }
    
    /**
     * Search locations
     */
    function searchLocations(locations, query) {
      if (!query || !query.trim()) return locations;
      
      const q = query.toLowerCase().trim();
      return locations.filter(loc => {
        if (loc.name && loc.name.toLowerCase().includes(q)) return true;
        if (loc.id && loc.id.toLowerCase().includes(q)) return true;
        if (loc.description && loc.description.toLowerCase().includes(q)) return true;
        return false;
      });
    }
    
    /**
     * Filter by type
     */
    function filterByTypes(locations, activeTypes) {
      if (!activeTypes || activeTypes.size === 0) return locations;
      return locations.filter(loc => activeTypes.has(loc.type));
    }
    
    /**
     * Apply filters and search
     */
    function applyFiltersAndSearch() {
      const searchQuery = document.getElementById('searchInput').value;
      let filtered = searchLocations(allLocations, searchQuery);
      filtered = filterByTypes(filtered, activeTags);
      renderLocations(filtered);
    }
    
    /**
     * Initialize the page
     */
    async function init() {
      try {
        // Load location data
        const [locations, maps] = await Promise.all([
          App.fetchData('locations.json'),
          App.fetchData('maps.json')
        ]);
        
        allLocations = locations || [];
        allMaps = maps || [];
        
        renderFilters();
        renderMapLinks();
        renderLocations(allLocations);
        
        // Search input handler
        const searchInput = document.getElementById('searchInput');
        searchInput.addEventListener('input', App.debounce(() => {
          applyFiltersAndSearch();
        }, 200));
        
        // Filter click handlers
        document.querySelectorAll('.filter-tag').forEach(el => {
          el.addEventListener('click', function(e) {
            const type = this.dataset.type;
            const checkbox = this.querySelector('input');
            
            if (activeTags.has(type)) {
              activeTags.delete(type);
              this.classList.remove('active');
              checkbox.checked = false;
            } else {
              activeTags.add(type);
              this.classList.add('active');
              checkbox.checked = true;
            }
            
            applyFiltersAndSearch();
          });
        });
        
      } catch (error) {
        console.error('Failed to initialize:', error);
        document.getElementById('locationTree').innerHTML = `
          <div class="error">ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ</div>
        `;
      }
    }
    
    // Initialize on page load
    document.addEventListener('DOMContentLoaded', init);
  </script>
  
  <style>
    .location-tree {
      margin-top: 1rem;
    }
    .location-node {
      margin-bottom: 0.5rem;
      border-left: 2px solid var(--border-color, #ddd);
      padding-left: 0.75rem;
    }
    .location-link {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem;
      border-radius: 4px;
      text-decoration: none;
      color: inherit;
      transition: background-color 0.2s;
    }
    .location-link:hover {
      background-color: var(--hover-bg, #f5f5f5);
    }
    .location-icon {
      font-size: 1.2rem;
    }
    .location-name {
      font-weight: 500;
    }
    .location-type {
      font-size: 0.75rem;
      margin-left: auto;
    }
    .location-desc {
      font-size: 0.85rem;
      color: var(--text-muted, #666);
      padding-left: 2.5rem;
      margin-top: -0.25rem;
      margin-bottom: 0.5rem;
    }
    .map-link {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      background: var(--primary-color, #4a6fa5);
      color: white;
      border-radius: 4px;
      text-decoration: none;
      font-size: 0.85rem;
    }
    .map-link:hover {
      opacity: 0.9;
    }
  </style>
</body>
</html>
